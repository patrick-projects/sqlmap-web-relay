<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>sqlmap Relay</title>
  <style>
    :root { --bg:#1a1e26; --surface:#232932; --border:#2d3544; --text:#e2e6ed;
            --dim:#8b929d; --accent:#00c896; --err:#ff5c5c; --warn:#f0a030;
            --blue:#8bb8f8; }
    * { box-sizing:border-box; margin:0; padding:0; }
    body { font:13px/1.5 system-ui,sans-serif; background:var(--bg); color:var(--text);
           padding:20px; max-width:640px; margin:0 auto; }

    /* ── Header ── */
    header { display:flex; align-items:center; gap:10px; margin-bottom:14px; }
    h1 { font-size:17px; color:var(--accent); white-space:nowrap; }
    .dot { width:9px; height:9px; border-radius:50%; background:var(--dim);
           display:inline-block; flex-shrink:0; }
    .dot.ok   { background:var(--accent); box-shadow:0 0 6px var(--accent); }
    .dot.run  { background:var(--accent); animation:pulse 1.2s infinite; }
    .dot.err  { background:var(--err); }
    .dot.warn { background:var(--warn); }
    @keyframes pulse { 0%,100%{opacity:1} 50%{opacity:.35} }
    #statusText { font-size:12px; color:var(--dim); }

    /* ── Panels ── */
    details { background:var(--surface); border:1px solid var(--border);
              border-radius:6px; padding:12px 14px; margin-bottom:12px; }
    summary { cursor:pointer; font-weight:600; font-size:12px; color:var(--accent);
              outline:none; user-select:none; }
    summary::-webkit-details-marker { color:var(--dim); }

    /* ── Burp setup ── */
    details ol { padding-left:18px; margin-top:8px; }
    details li { margin-bottom:10px; font-size:11.5px; color:var(--text); }
    details li b { color:var(--accent); }
    .rule { display:block; font:11px/1.4 'SF Mono',Menlo,Consolas,monospace;
            background:#0d0f12; color:#c8d0dc; padding:5px 9px; border-radius:4px;
            margin:3px 0; word-break:break-all; }
    .rule em { color:var(--warn); font-style:normal; }
    .note { font-size:10.5px; color:var(--dim); margin-top:4px; }
    .section-label { font-size:10px; text-transform:uppercase; letter-spacing:.5px;
                     color:var(--dim); margin:8px 0 4px; }

    /* ── Form ── */
    .form { background:var(--surface); border:1px solid var(--border);
            border-radius:6px; padding:14px; margin-bottom:12px; }
    label { display:block; font-size:11px; color:var(--dim); margin-bottom:3px; }
    input, select { width:100%; padding:8px 10px; background:#0d0f12;
                    border:1px solid var(--border); border-radius:4px;
                    color:var(--text); font-size:12px; margin-bottom:10px; }
    input:focus, select:focus { outline:none; border-color:var(--accent); }
    .grid { display:grid; grid-template-columns:1fr 1fr 1fr 1fr; gap:8px; }
    .grid select { margin-bottom:6px; }

    /* ── Controls ── */
    .controls { display:flex; gap:8px; margin-bottom:12px; align-items:center; }
    button { border:none; padding:9px 20px; border-radius:4px;
             font-weight:600; cursor:pointer; font-size:12px; }
    button:hover { opacity:.88; }
    #startBtn { background:var(--accent); color:#0d0f12; }
    #startBtn:disabled { opacity:.4; cursor:default; }
    #stopBtn  { background:var(--err); color:#fff; }
    #stopBtn:disabled { opacity:.25; cursor:default; }
    .spacer { flex:1; }
    .badge { font-size:11px; color:var(--dim); }
    .badge b { color:var(--text); }

    /* ── Logs ── */
    .log { background:#0d0f12; border:1px solid var(--border); border-radius:6px;
           overflow-y:auto; padding:8px 10px;
           font:11px/1.55 'SF Mono',Menlo,Consolas,monospace; white-space:pre-wrap;
           word-break:break-all; }
    #sqlmapLog { height:320px; margin-bottom:12px; }
    #sqlmapLog:empty::after { content:"sqlmap output will appear here …"; color:var(--dim); }
    #relayLog  { height:180px; margin-top:8px; }
    #relayLog:empty::after  { content:"Relay activity …"; color:var(--dim); }

    .l-cmd  { color:var(--accent); }
    .l-info { color:var(--dim); }
    .l-warn { color:var(--warn); }
    .l-vuln { color:#ff79c6; font-weight:600; }
    .l-req  { color:var(--accent); }
    .l-resp { color:var(--blue); }
    .l-err  { color:var(--err); }
    .l-time { color:#555e6e; margin-right:6px; }
  </style>
</head>
<body>

<header>
  <h1>sqlmap Browser Relay</h1>
  <span class="dot" id="dot"></span>
  <span id="statusText">connecting …</span>
</header>

<!-- ── Burp Setup ── -->
<details id="burpSetup">
  <summary>Burp Suite Setup (required)</summary>
  <ol>
    <li><b>Proxy the browser through Burp</b> (127.0.0.1:8080 by default).</li>
    <li>
      Open <b>Proxy &rarr; Options &rarr; Match and Replace</b> and add all of these rules:
      <div class="section-label">Response rules (CORS &mdash; allow browser to read cross-origin responses)</div>
      <span class="rule">Type: <em>Response header</em> | Match: <em>(empty)</em> | Replace: <em>Access-Control-Allow-Origin: *</em></span>
      <span class="rule">Type: <em>Response header</em> | Match: <em>(empty)</em> | Replace: <em>Access-Control-Expose-Headers: *</em></span>
      <p class="note">These two rules let the relay JavaScript read the full response body and headers from the target.</p>

      <div class="section-label">Request rules (make requests look same-origin)</div>
      <span class="rule">Type: <em>Request header</em> | Match: <em>Sec-Fetch-Site: cross-site</em> | Replace: <em>Sec-Fetch-Site: same-origin</em></span>
      <span class="rule">Type: <em>Request header</em> | Match: <em>Sec-Fetch-Mode: cors</em> | Replace: <em>Sec-Fetch-Mode: navigate</em></span>
      <span class="rule">Type: <em>Request header</em> | Match: <em>Sec-Fetch-Dest: empty</em> | Replace: <em>Sec-Fetch-Dest: document</em></span>
      <span class="rule">Type: <em>Request header</em> | Regex: <em>&#x2713;</em> | Match: <em>^Origin:.*$</em> | Replace: <em>(empty &mdash; removes the header)</em></span>

      <p class="note">These four rules make requests look like they come from the target site, not the relay page.</p>

      <div class="section-label">Cookie rule (if target requires authentication)</div>
      <span class="rule">Type: <em>Request header</em> | Match: <em>(empty)</em> | Replace: <em>Cookie: PASTE_YOUR_FULL_COOKIE_HERE</em></span>
      <p class="note">The browser cannot set Cookie via JavaScript &mdash; this Burp rule is the only way to attach cookies.</p>
    </li>
  </ol>
</details>

<!-- ── Target Form ── -->
<div class="form">
  <label>Target URL</label>
  <input id="url" type="url" placeholder="http://target.com/page?id=1" autocomplete="url">

  <label>POST Data <span style="color:var(--dim)">(optional)</span></label>
  <input id="data" type="text" placeholder="user=admin&pass=test" autocomplete="off">

  <label>Cookie <span style="color:var(--dim)">(optional &mdash; must ALSO be added as a Burp request rule above)</span></label>
  <input id="cookie" type="text" placeholder="PHPSESSID=abc123; token=xyz" autocomplete="off">

  <div class="grid">
    <div>
      <label>Technique</label>
      <select id="technique">
        <option value="">All</option>
        <option value="B">Boolean</option>
        <option value="T">Time</option>
        <option value="E">Error</option>
        <option value="U">Union</option>
        <option value="S">Stacked</option>
      </select>
    </div>
    <div>
      <label>Level</label>
      <select id="level">
        <option value="1" selected>1</option>
        <option value="2">2</option>
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5">5</option>
      </select>
    </div>
    <div>
      <label>Risk</label>
      <select id="risk">
        <option value="1" selected>1</option>
        <option value="2">2</option>
        <option value="3">3</option>
      </select>
    </div>
    <div>
      <label>Threads</label>
      <select id="threads">
        <option value="1" selected>1</option>
        <option value="2">2</option>
        <option value="4">4</option>
        <option value="8">8</option>
      </select>
    </div>
  </div>

  <div style="display:flex; gap:16px; margin:6px 0 12px; flex-wrap:wrap;">
    <label style="display:flex; align-items:center; gap:5px; cursor:pointer; margin:0;">
      <input type="checkbox" id="randomAgent" style="width:auto; margin:0;"> <span>Random User-Agent</span>
    </label>
    <label style="display:flex; align-items:center; gap:5px; cursor:pointer; margin:0;">
      <input type="checkbox" id="flushSession" style="width:auto; margin:0;"> <span>Flush Session</span>
    </label>
    <label style="display:flex; align-items:center; gap:5px; cursor:pointer; margin:0;">
      <span>Verbosity</span>
      <select id="verbose" style="width:auto; margin:0; padding:4px 6px;">
        <option value="1" selected>1</option>
        <option value="2">2</option>
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5">5</option>
        <option value="6">6</option>
      </select>
    </label>
  </div>

  <label>Extra Flags <span style="color:var(--dim)">(optional)</span></label>
  <input id="extra" type="text" placeholder="--tamper=space2comment --dbs --dump" autocomplete="off" inputmode="text">
</div>

<!-- ── Controls ── -->
<div class="controls">
  <button id="startBtn" onclick="doStart()">Start Scan</button>
  <button id="stopBtn" onclick="doStop()" disabled>Stop</button>
  <div class="spacer"></div>
  <span class="badge">Relayed: <b id="relayedN">0</b> | Errors: <b id="errorsN">0</b></span>
</div>

<!-- ── Question Prompt (hidden by default) ── -->
<div id="questionPrompt" style="display:none; background:var(--surface); border:1px solid var(--border); border-radius:6px; padding:14px; margin-bottom:12px;">
  <div style="font-weight:600; color:var(--warn); margin-bottom:8px;">sqlmap Question:</div>
  <div id="questionText" style="font:11px monospace; color:var(--text); margin-bottom:10px; white-space:pre-wrap;"></div>
  <div style="display:flex; gap:8px;">
    <input id="questionAnswer" type="text" placeholder="Your answer (Y/n/etc)" style="flex:1; padding:8px; background:#0d0f12; border:1px solid var(--border); border-radius:4px; color:var(--text); font-size:12px;" autocomplete="off">
    <button id="questionSubmit" onclick="submitAnswer()" style="background:var(--accent); color:#0d0f12; border:none; padding:8px 18px; border-radius:4px; font-weight:600; cursor:pointer;">Send</button>
  </div>
</div>

<!-- ── sqlmap Output ── -->
<div id="sqlmapLog" class="log"></div>

<!-- ── Relay Activity ── -->
<details>
  <summary>Relay Activity</summary>
  <div id="relayLog" class="log"></div>
</details>

<script>
// ── Config ──────────────────────────────────────────────────────────────────
const API      = location.origin;
const POLL_MS  = 400;
const LOG_MS   = 600;

// ── DOM refs ────────────────────────────────────────────────────────────────
const $ = id => document.getElementById(id);
const $dot       = $("dot");
const $status    = $("statusText");
const $sqlLog    = $("sqlmapLog");
const $relayLog  = $("relayLog");
const $startBtn  = $("startBtn");
const $stopBtn   = $("stopBtn");
const $relayedN  = $("relayedN");
const $errorsN   = $("errorsN");
const $qPrompt   = $("questionPrompt");
const $qText     = $("questionText");
const $qAnswer   = $("questionAnswer");
const $qSubmit   = $("questionSubmit");

// ── State ───────────────────────────────────────────────────────────────────
let relayActive = true;
let relayPolling = false;
let relayed = 0, errors = 0;
let logOffset = 0;
let scanRunning = false;
let cookieWarned = false;   // only warn once per scan

// ── Helpers ─────────────────────────────────────────────────────────────────
function esc(s) { return s.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;"); }
function ts() {
  const d = new Date();
  return [d.getHours(),d.getMinutes(),d.getSeconds()].map(n=>String(n).padStart(2,"0")).join(":");
}
function setStatus(cls, txt) { $dot.className="dot "+cls; $status.textContent=txt; }
function appendLine(el, html, cls) {
  const d = document.createElement("div");
  d.className = cls||"";
  d.innerHTML = html;
  el.appendChild(d);
  el.scrollTop = el.scrollHeight;
}
function rlog(msg, cls) {
  appendLine($relayLog, '<span class="l-time">'+ts()+'</span>'+esc(msg), cls||"l-info");
}

// ── Local Storage persistence ───────────────────────────────────────────────
const FIELDS = ["url","data","cookie","technique","level","risk","threads","extra","verbose"];
const CHECKBOXES = ["randomAgent","flushSession"];
function save() {
  const o = {};
  FIELDS.forEach(f => o[f] = $(f).value);
  CHECKBOXES.forEach(f => o[f] = $(f).checked);
  try { localStorage.setItem("sqlmap_relay", JSON.stringify(o)); } catch(_){}
}
function load() {
  try {
    const o = JSON.parse(localStorage.getItem("sqlmap_relay")||"{}");
    FIELDS.forEach(f => { if (o[f]!=null) $(f).value = o[f]; });
    CHECKBOXES.forEach(f => { if (o[f]!=null) $(f).checked = o[f]; });
  } catch(_){}
}
load();
FIELDS.forEach(f => { $(f).addEventListener("input", save); $(f).addEventListener("change", save); });
CHECKBOXES.forEach(f => { $(f).addEventListener("change", save); });

// ── Execute a relayed request via fetch() ───────────────────────────────────
// CORS preflight avoidance strategy:
// Setting custom headers on fetch() triggers an OPTIONS preflight. If the target
// returns non-2xx for OPTIONS (very common), the preflight fails and the actual
// request is NEVER sent. To avoid this, we ONLY set "CORS-safelisted" headers
// on the fetch. All other headers are handled by Burp Match and Replace rules.
//
// CORS-safelisted (no preflight): Accept, Accept-Language, Content-Language,
//   Content-Type (only: application/x-www-form-urlencoded, multipart/form-data,
//   text/plain)
//
// Everything else (Cookie, User-Agent, Referer, etc.) must go through Burp.
const CORS_SAFE_CONTENT_TYPES = new Set([
  "application/x-www-form-urlencoded",
  "multipart/form-data",
  "text/plain",
]);

async function execReq(req) {
  // redirect:"manual" preserves 302 responses for sqlmap's detection logic.
  const opts = { method:req.method, credentials:"omit",
                 referrerPolicy:"no-referrer", redirect:"manual" };

  // Warn once if we're dropping a Cookie header
  if (!cookieWarned) {
    for (const k of Object.keys(req.headers||{})) {
      if (k.toLowerCase() === "cookie") {
        cookieWarned = true;
        rlog("\u26a0 Cookie header dropped (browser-forbidden) \u2014 make sure the Burp Cookie rule is set!", "l-warn");
        break;
      }
    }
  }

  // Only set CORS-safelisted headers to avoid triggering OPTIONS preflight.
  // Burp handles all other headers (Cookie, User-Agent override, Referer, etc.)
  const h = new Headers();
  const reqHeaders = req.headers || {};
  for (const [k,v] of Object.entries(reqHeaders)) {
    const low = k.toLowerCase();
    if (low === "accept" || low === "accept-language" || low === "content-language") {
      try { h.set(k, v); } catch(_) {}
    } else if (low === "content-type") {
      // Only set Content-Type if it's CORS-safe; otherwise let browser default
      const baseType = (v || "").split(";")[0].trim().toLowerCase();
      if (CORS_SAFE_CONTENT_TYPES.has(baseType)) {
        try { h.set(k, v); } catch(_) {}
      }
      // Non-safe Content-Types (application/json, etc.) are omitted to avoid preflight.
      // The body is still sent; many servers parse based on content, not Content-Type.
    }
  }
  opts.headers = h;
  if (req.body && ["POST","PUT","PATCH"].includes(req.method)) opts.body = req.body;

  const t0 = performance.now();
  let r;
  try {
    r = await fetch(req.url, opts);
  } catch(e) {
    // redirect:"manual" returns opaque redirects for cross-origin 3xx.
    // These throw or return status 0. Return a synthetic 302.
    return { status:302, statusText:"Redirect (opaque)", headers:{}, body:"" };
  }

  // Track relay latency for time-based injection calibration
  const ms = Math.round(performance.now() - t0);

  // Handle opaque redirect (status 0)
  if (r.type === "opaqueredirect" || r.status === 0) {
    return { status:302, statusText:"Redirect (opaque)", headers:{}, body:"", _relayMs:ms };
  }

  const rh = {}; r.headers.forEach((v,k)=>{ rh[k]=v; });
  return { status:r.status, statusText:r.statusText, headers:rh, body:await r.text(), _relayMs:ms };
}

async function postResp(id, data) {
  await fetch(API+"/relay/response/"+id, {
    method:"POST", headers:{"Content-Type":"application/json"}, body:JSON.stringify(data)
  });
}

// ── Relay poll loop ─────────────────────────────────────────────────────────
async function relayPoll() {
  if (!relayActive || relayPolling) return;
  relayPolling = true;
  try {
    const res = await fetch(API+"/relay/pending");
    const reqs = await res.json();
    if (reqs.length) {
      setStatus("run", "relaying "+reqs.length+" …");
      await Promise.all(reqs.map(async req => {
        const short = req.method+" "+req.url.substring(0,72);
        try {
          rlog("\u2192 "+short, "l-req");
          const resp = await execReq(req);
          await postResp(req.id, resp);
          relayed++;
          const ms = resp._relayMs ? " "+resp._relayMs+"ms" : "";
          rlog("\u2190 "+resp.status+" ("+resp.body.length+"b"+ms+")", "l-resp");
        } catch(e) {
          errors++;
          rlog("\u2717 "+short+" \u2014 "+e.message, "l-err");
          await postResp(req.id, {status:502,statusText:"Relay Error",headers:{},body:e.message}).catch(()=>{});
        }
        $relayedN.textContent=relayed; $errorsN.textContent=errors;
      }));
    }
    if (scanRunning) setStatus("run","scan running …");
    else setStatus("ok","polling …");
  } catch(e) {
    setStatus("err","relay unreachable");
  }
  relayPolling = false;
}

// ── sqlmap log poll ─────────────────────────────────────────────────────────
async function logPoll() {
  try {
    const res = await fetch(API+"/scan/log?offset="+logOffset);
    const d = await res.json();
    if (d.lines.length) {
      d.lines.forEach(line => {
        let cls = "l-info";
        if (/^\[relay\]/.test(line))                          cls = "l-cmd";
        else if (/\bvulnerable\b/i.test(line)||/injection/i.test(line)) cls = "l-vuln";
        else if (/\[WARNING\]/i.test(line))                   cls = "l-warn";
        else if (/\[ERROR\]/i.test(line)||/\[CRITICAL\]/i.test(line)) cls = "l-err";
        appendLine($sqlLog, esc(line), cls);
      });
      logOffset += d.lines.length;
    }
    
    // Show/hide question prompt (only focus once when it first appears)
    if (d.question) {
      const isNew = ($qPrompt.style.display === "none");
      $qText.textContent = d.question;
      $qPrompt.style.display = "";
      if (isNew) $qAnswer.focus();
    } else {
      $qPrompt.style.display = "none";
    }
    
    // Only reset UI on TERMINAL statuses — not "idle" (race) or "running"
    if (scanRunning && ["finished","error","stopped"].includes(d.status)) {
      scanRunning = false;
      $startBtn.disabled = false;
      $stopBtn.disabled = true;
      $qPrompt.style.display = "none";
      setStatus(d.status==="finished"?"ok":"warn", "scan "+d.status);
    }
  } catch(_){}
}

// ── Submit answer to sqlmap question ────────────────────────────────────────
async function submitAnswer() {
  const ans = $qAnswer.value.trim() || "Y";  // Default to Y if empty
  $qAnswer.value = "";
  $qPrompt.style.display = "none";
  
  try {
    await fetch(API+"/scan/answer", {
      method:"POST",
      headers:{"Content-Type":"application/json"},
      body:JSON.stringify({answer:ans})
    });
    appendLine($sqlLog, "[relay] Answer sent: "+esc(ans), "l-info");
  } catch(e) {
    appendLine($sqlLog, "[relay] Failed to send answer: "+esc(e.message), "l-err");
  }
}

// Allow Enter key to submit answer
$qAnswer.addEventListener("keypress", e => {
  if (e.key === "Enter") submitAnswer();
});

// ── Start / Stop ────────────────────────────────────────────────────────────
async function doStart() {
  const url = $("url").value.trim();
  if (!url) { alert("Enter a Target URL"); return; }

  // Reset
  $sqlLog.innerHTML = "";
  logOffset = 0;
  relayed = 0; errors = 0;
  cookieWarned = false;
  $relayedN.textContent="0"; $errorsN.textContent="0";

  const body = {
    url,
    data:         $("data").value.trim()      || undefined,
    cookie:       $("cookie").value.trim()     || undefined,
    technique:    $("technique").value         || undefined,
    level:        $("level").value,
    risk:         $("risk").value,
    threads:      $("threads").value,
    verbose:      $("verbose").value,
    randomAgent:  $("randomAgent").checked     || undefined,
    flushSession: $("flushSession").checked    || undefined,
    extra:        $("extra").value.trim()      || undefined,
  };

  $startBtn.disabled = true;
  $stopBtn.disabled  = false;
  scanRunning = true;
  setStatus("run","starting scan …");

  try {
    const r = await fetch(API+"/scan/start", {
      method:"POST", headers:{"Content-Type":"application/json"},
      body:JSON.stringify(body)
    });
    const j = await r.json();
    if (!j.ok) {
      appendLine($sqlLog, esc("[relay] "+j.message), "l-err");
      scanRunning = false;
      $startBtn.disabled = false;
      $stopBtn.disabled = true;
      setStatus("err","start failed");
    }
  } catch(e) {
    appendLine($sqlLog, esc("[relay] "+e.message), "l-err");
    scanRunning = false;
    $startBtn.disabled = false;
    $stopBtn.disabled = true;
    setStatus("err","start failed");
  }
}

async function doStop() {
  $stopBtn.disabled = true;
  scanRunning = false;
  $startBtn.disabled = false;
  setStatus("warn", "stopping …");
  try {
    const r = await fetch(API+"/scan/stop", {method:"POST"});
    const j = await r.json();
    if (j.ok) {
      appendLine($sqlLog, "[relay] Scan stopped by user", "l-warn");
      setStatus("warn", "scan stopped");
    } else {
      setStatus("ok", "no scan to stop");
    }
  } catch(e) {
    setStatus("warn", "scan stopped");
  }
}

// ── Boot ────────────────────────────────────────────────────────────────────
setStatus("ok","polling …");
rlog("Relay connected \u2013 waiting for scan","l-info");
setInterval(relayPoll, POLL_MS);
setInterval(logPoll, LOG_MS);
</script>
</body>
</html>
